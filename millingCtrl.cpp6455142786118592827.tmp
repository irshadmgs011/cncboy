#include "millingCtrl.h"

#define STATE_READY 0
#define STATE_RUNNING 1
#define STATE_PAUSED 2

MillingCtrl::MillingCtrl(UI *ui, KeyPad *keyPad) 
    : ui(*ui), keyPad(*keyPad) {
}

void MillingCtrl::start(File _file) {
  file = _file;
  totalLines = 0;

  String line;
  long loadedBytes = 0;
  float filesize = file.size();
  float progress = 0;
  float newProgress = 0;

  Serial.print("Reading milling ");
  Serial.println(file.name());

  showLoading(progress);

  while (file.available()) {
    line = file.readStringUntil('\n');
    if (isValidCommand(line)) {
      totalLines++;
      loadedBytes += line.length();
      newProgress = loadedBytes / filesize;
      if (newProgress - 0.02 > progress) {
        progress = newProgress;
        showLoading(progress);
      }
    }
  }

  Serial.print(totalLines);
  Serial.println(" total commands to execute");

  // done loading
  state = STATE_READY;
}

void MillingCtrl::stop() {
  if (file != NULL) {
    file.close();
  }
}

byte MillingCtrl::update(int deltaMs) {
  everySecondTimer -= deltaMs;
  if (everySecondTimer <= 0) {
    everySecondTimer += 1000;
    queryStatusReport();

    if (state == STATE_RUNNING) {
      elapsedSeconds++;
    }
  }

  if (keyPad.isKeyPressed(KEYCODE_A)) { // back
    if (state == STATE_READY) {
      return MILLING_RESULT_BACK;
    }
  }
  else if (keyPad.isKeyPressed(KEYCODE_B)) { // stop
    Serial.println("Stopped");
    state = STATE_READY; // TODO: confirm?
  }
  else if (keyPad.isKeyPressed(KEYCODE_C)) { // pause
    Serial.println("Paused");
    if (state == STATE_RUNNING) {
      state = STATE_PAUSED;
    }
  }
  else if (keyPad.isKeyPressed(KEYCODE_D)) { // play
    Serial.println("Running milling " + String(file.name()));
    if (state == STATE_READY) {
      reset();
      state = STATE_RUNNING;
    }
    else if (state == STATE_PAUSED) {
      state = STATE_RUNNING;
    }
  }

  // TODO: zero out the machine function

  switch (state) {
    case STATE_READY:
      showReady();
      break;
    case STATE_RUNNING:
      streamCommands();
      showRunning();
      break;
    case STATE_PAUSED:
      showRunning();
      break;
  }

  return MILLING_RESULT_NONE;
}

void MillingCtrl::reset() {
  file.seek(0); // reset file
  everySecondTimer = 0;
  elapsedSeconds = 0;
  currentLine = 0;
  currentCommand = "";
  commandAck = true;
  state = STATE_READY;
}

void MillingCtrl::streamCommands() {
  readResponse();

  if (commandAck) { // can send another command, previous one was ACK
    sendNextCommand();
  }
}

void MillingCtrl::queryStatusReport() {
  Serial2.print('?');
  Serial2.print('\n');
  Serial2.flush();
  delay(1);
}

void MillingCtrl::sendNextCommand() {
  String line;
  
  if (file.available()) {
    line = file.readStringUntil('\n');
    if (isValidCommand(line)) {
      line.trim();
      Serial2.print(line);
      Serial2.print('\n');
      Serial2.flush();

      Serial.println(line);
      currentCommand = line;
      currentLine++;
      commandAck = false;

      delay(10);
    }
  }
  else {
    Serial.println("Done " + String(file.name()));
    // todo
    //state = STATE_READY;
  }
}

void MillingCtrl::readResponse() {
  char current;
  String response;

  while (Serial2.available()) {
    current = char(Serial2.read());
    if (current == '\n') {
      break; // only one reply at a time
    }
    response += current;
  }

  if (response.length() > 0) {
    response.trim();
    Serial.println(response);

    if (response == "ok") {
      // ok response
      commandAck = true;
    }
    else if (response.startsWith("<")) {
      // machine status report
      parseStatusReport(response);
    }
    else if (response.startsWith("error") != -1) {
      // error reponse
      currentCommand = response;
      state = STATE_PAUSED;
      error = true;
    }
  }
}

void MillingCtrl::parseStatusReport(String report) {
  char token;
  String value;

  byte reportIndex;
  byte coordinateIndex;

  // format: <Run|MPos:-0.950,-4.887,-2.500|FS:1010,1000>

  for (int i = 0; i < report.length(); i++) {
    token = report.chatAt(i);
    if (token == '<') {
      continue; // start
      value = "";
    }
    else if (token == '|') {
      
    }
    else if (token == ':') {
      
    }
    else if (token == ',') {
      
    }
    else if (token == '>') {
      break; // stop
    }
    else {
      value += token;
    }
  }
}

void MillingCtrl::showRunning() {
  float progress = (float) currentLine / totalLines;

  ui.firstPage();
  do {
    ui.setFont(u8g2_font_5x8_mr);
    ui.drawStr(0, 7, file.name());
    ui.drawProgressBar(9, progress);

    ui.drawAxisIcon(0, 20);
    ui.drawStr(8, 26, "X-65.44");
    ui.drawStr(49, 26, "Y21.626");
    ui.drawStr(90, 26, "Z-2");

    ui.drawClockIcon(0, 28);
    ui.drawStr(8, 35, ui.formatTime(elapsedSeconds));

    ui.drawStr(0, 46, currentCommand);
    
    ui.drawStopButton(1);
    if (state == STATE_RUNNING) {
      ui.drawPauseButton(2);
    }
    if (state == STATE_PAUSED) {
      ui.drawPlayButton(3);
    }
  } while (ui.nextPage());
}

void MillingCtrl::showReady() {
  ui.firstPage();
  do {
    ui.setFont(u8g2_font_5x8_mr);
    ui.drawStr(0, 7, file.name());
    ui.drawStr(0, 16, "Ready " + String(totalLines) + " commands");
    //ui.drawProgressBar(9, progress);

    // commands history
    // elapsed time ? estimated time?

    ui.drawTextButton(0, "Back");
    ui.drawPlayButton(3);
  } while (ui.nextPage());
}

void MillingCtrl::showLoading(float progress) {
  ui.firstPage();
  do {
    ui.setFont(u8g2_font_5x8_mr);
    ui.drawStr(0, 7, file.name());
    ui.drawStr(0, 20, "Reading file");
    ui.drawProgressBar(22, progress);
  } while (ui.nextPage());
}

boolean MillingCtrl::isValidCommand(String line) {
  line.trim();
  if (line.length() == 0) {
    return false;
  }
  if (line.charAt(0) == ';' || line.charAt(0) == '%' || line.charAt(0) == '(') { // skip comments
    return false;
  }
  return true;
}
